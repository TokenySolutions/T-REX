/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2019, Tokeny s√†rl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.6.2;

import "./IToken.sol";
import "@onchain-id/solidity/contracts/IERC734.sol";
import "@onchain-id/solidity/contracts/IERC735.sol";
import "@onchain-id/solidity/contracts/IIdentity.sol";
import "../registry/IClaimTopicsRegistry.sol";
import "../registry/IIdentityRegistry.sol";
import "../compliance/ICompliance.sol";
import "../roles/AgentRole.sol";
import "openzeppelin-solidity/contracts/math/SafeMath.sol";


contract Token is IToken, AgentRole {
    using SafeMath for uint256;

    /// ERC20 basic variables
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    /// Token information
    string private tokenName;
    string private tokenSymbol;
    uint8 private tokenDecimals;
    address private tokenOnchainID;
    string constant private TOKEN_VERSION = "3.1.0";

    /// Variables of freeze and pause functions
    mapping(address => bool) private frozen;
    mapping(address => uint256) private frozenTokens;

    bool private tokenPaused = false;

    /// Identity Registry contract used by the onchain validator system
    IIdentityRegistry private tokenIdentityRegistry;

    /// Compliance contract linked to the onchain validator system
    ICompliance private tokenCompliance;

   /**
    *  @dev the constructor initiates the token contract
    *  msg.sender is set automatically as the owner of the smart contract
    *  @param _identityRegistry the address of the Identity registry linked to the token
    *  @param _compliance the address of the compliance contract linked to the token
    *  @param _name the name of the token
    *  @param _symbol the symbol of the token
    *  @param _decimals the decimals of the token
    *  @param _onchainID the address of the onchainID of the token
    *  emits an `UpdatedTokenInformation` event
    *  emits an `IdentityRegistryAdded` event
    *  emits a `ComplianceAdded` event
    */
    constructor(
        address _identityRegistry,
        address _compliance,
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _onchainID
        )
    public {
        tokenName = _name;
        tokenSymbol = _symbol;
        tokenDecimals = _decimals;
        tokenOnchainID = _onchainID;
        tokenIdentityRegistry = IIdentityRegistry(_identityRegistry);
        emit IdentityRegistryAdded(_identityRegistry);
        tokenCompliance = ICompliance(_compliance);
        emit ComplianceAdded(_compliance);
        emit UpdatedTokenInformation(tokenName, tokenSymbol, tokenDecimals, TOKEN_VERSION, tokenOnchainID);
    }

    /// Modifier to make a function callable only when the contract is not paused.
    modifier whenNotPaused() {
        require(!tokenPaused, "Pausable: paused");
        _;
    }

    /// Modifier to make a function callable only when the contract is paused.
    modifier whenPaused() {
        require(tokenPaused, "Pausable: not paused");
        _;
    }

   /**
    *  @dev See {IERC20-totalSupply}.
    */
    function totalSupply() external override view returns (uint256) {
        return _totalSupply;
    }

   /**
    *  @dev See {IERC20-balanceOf}.
    */
    function balanceOf(address _userAddress) public override view returns (uint256) {
        return _balances[_userAddress];
    }

   /**
    *  @dev See {IERC20-allowance}.
    */
    function allowance(address _owner, address _spender) external override view virtual returns (uint256) {
        return _allowances[_owner][_spender];
    }

   /**
    *  @dev See {IERC20-approve}.
    */
    function approve(address _spender, uint256 _amount) external override virtual returns (bool) {
        _approve(msg.sender, _spender, _amount);
        return true;
    }

   /**
    *  @dev See {ERC20-increaseAllowance}.
    */
    function increaseAllowance(address _spender, uint256 _addedValue) external virtual returns (bool) {
        _approve(msg.sender, _spender, _allowances[msg.sender][_spender].add(_addedValue));
        return true;
    }

   /**
    *  @dev See {ERC20-decreaseAllowance}.
    */
    function decreaseAllowance(address _spender, uint256 _subtractedValue) external virtual returns (bool) {
        _approve(msg.sender, _spender, _allowances[msg.sender][_spender].sub(_subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

   /**
    *  @dev See {ERC20-_mint}.
    */
    function _transfer(address _from, address _to, uint256 _amount) internal virtual {
        require(_from != address(0), "ERC20: transfer from the zero address");
        require(_to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(_from, _to, _amount);

        _balances[_from] = _balances[_from].sub(_amount, "ERC20: transfer amount exceeds balance");
        _balances[_to] = _balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
    }

   /**
    *  @dev See {ERC20-_mint}.
    */
    function _mint(address _userAddress, uint256 _amount) internal virtual {
        require(_userAddress != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), _userAddress, _amount);

        _totalSupply = _totalSupply.add(_amount);
        _balances[_userAddress] = _balances[_userAddress].add(_amount);
        emit Transfer(address(0), _userAddress, _amount);
    }

   /**
    *  @dev See {ERC20-_burn}.
    */
    function _burn(address _userAddress, uint256 _amount) internal virtual {
        require(_userAddress != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(_userAddress, address(0), _amount);

        _balances[_userAddress] = _balances[_userAddress].sub(_amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(_amount);
        emit Transfer(_userAddress, address(0), _amount);
    }

   /**
    *  @dev See {ERC20-_approve}.
    */
    function _approve(address _owner, address _spender, uint256 _amount) internal virtual {
        require(_owner != address(0), "ERC20: approve from the zero address");
        require(_spender != address(0), "ERC20: approve to the zero address");

        _allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
    }

   /**
    *  @dev See {ERC20-_beforeTokenTransfer}.
    */
    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal virtual { }


   /**
    *  @dev See {IToken-decimals}.
    */
    function decimals() external override view returns (uint8){
        return tokenDecimals;
    }

   /**
    *  @dev See {IToken-name}.
    */
    function name() external override view returns (string memory){
        return tokenName;
    }

   /**
    *  @dev See {IToken-onchainID}.
    */
    function onchainID() external override view returns (address){
        return tokenOnchainID;
    }

   /**
    *  @dev See {IToken-symbol}.
    */
    function symbol() external override view returns (string memory){
        return tokenSymbol;
    }

   /**
    *  @dev See {IToken-version}.
    */
    function version() external override view returns (string memory){
        return TOKEN_VERSION;
    }

   /**
    *  @dev See {IToken-setName}.
    */
    function setName(string calldata _name) external override onlyOwner {
        tokenName = _name;
        emit UpdatedTokenInformation(tokenName, tokenSymbol, tokenDecimals, TOKEN_VERSION, tokenOnchainID);
    }

   /**
    *  @dev See {IToken-setSymbol}.
    */
    function setSymbol(string calldata _symbol) external override onlyOwner {
        tokenSymbol = _symbol;
        emit UpdatedTokenInformation(tokenName, tokenSymbol, tokenDecimals, TOKEN_VERSION, tokenOnchainID);
    }

   /**
    *  @dev See {IToken-setOnchainID}.
    */
    function setOnchainID(address _onchainID) external override onlyOwner {
        tokenOnchainID = _onchainID;
        emit UpdatedTokenInformation(tokenName, tokenSymbol, tokenDecimals, TOKEN_VERSION, tokenOnchainID);
    }

   /**
    *  @dev See {IToken-paused}.
    */
    function paused() external override view returns (bool) {
        return tokenPaused;
    }

   /**
    *  @dev See {IToken-isFrozen}.
    */
    function isFrozen(address _userAddress) external override view returns (bool) {
        return frozen[_userAddress];
    }

   /**
    *  @dev See {IToken-getFrozenTokens}.
    */
    function getFrozenTokens(address _userAddress) external override view returns (uint256) {
        return frozenTokens[_userAddress];
    }

   /**
    *  @notice ERC-20 overridden function that include logic to check for trade validity.
    *  Require that the msg.sender and to addresses are not frozen.
    *  Require that the value should not exceed available balance .
    *  Require that the to address is a verified address
    *  @param _to The address of the receiver
    *  @param _amount The number of tokens to transfer
    *  @return `true` if successful and revert if unsuccessful
    */
    function transfer(address _to, uint256 _amount) public override whenNotPaused returns (bool) {
        require(!frozen[_to] && !frozen[msg.sender], "wallet is frozen");
        require(_amount <= balanceOf(msg.sender).sub(frozenTokens[msg.sender]), "Insufficient Balance");
        if (tokenIdentityRegistry.isVerified(_to) && tokenCompliance.canTransfer(msg.sender, _to, _amount)) {
            tokenCompliance.transferred(msg.sender, _to, _amount);
            _transfer(msg.sender, _to, _amount);
            return true;
        }
        revert("Transfer not possible");
    }

   /**
    *  @dev See {IToken-pause}.
    */
    function pause() external override onlyAgent whenNotPaused {
        tokenPaused = true;
        emit Paused(msg.sender);
    }

   /**
    *  @dev See {IToken-unpause}.
    */
    function unpause() external override onlyAgent whenPaused {
        tokenPaused = false;
        emit Unpaused(msg.sender);
    }

   /**
    *  @dev See {IToken-identityRegistry}.
    */
    function identityRegistry() external override view returns (IIdentityRegistry) {
        return tokenIdentityRegistry;
    }

   /**
    *  @dev See {IToken-compliance}.
    */
    function compliance() external override view returns (ICompliance) {
        return tokenCompliance;
    }

   /**
    *  @dev See {IToken-batchTransfer}.
    */
    function batchTransfer(address[] calldata _toList, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _toList.length; i++) {
            transfer(_toList[i], _amounts[i]);
        }
    }

   /**
    *  @notice ERC-20 overridden function that include logic to check for trade validity.
    *  Require that the from and to addresses are not frozen.
    *  Require that the value should not exceed available balance .
    *  Require that the to address is a verified address
    *  @param _from The address of the sender
    *  @param _to The address of the receiver
    *  @param _amount The number of tokens to transfer
    *  @return `true` if successful and revert if unsuccessful
    */
    function transferFrom(address _from, address _to, uint256 _amount) external override whenNotPaused returns (bool) {
        require(!frozen[_to] && !frozen[_from], "wallet is frozen");
        require(_amount <= balanceOf(_from).sub(frozenTokens[_from]), "Insufficient Balance");
        if (tokenIdentityRegistry.isVerified(_to) && tokenCompliance.canTransfer(_from, _to, _amount)) {
            tokenCompliance.transferred(_from, _to, _amount);
            _transfer(_from, _to, _amount);
            _approve(_from, msg.sender, _allowances[_from][msg.sender].sub(_amount, "TREX: transfer amount exceeds allowance"));
            return true;
        }

        revert("Transfer not possible");
    }

   /**
    *  @dev See {IToken-forcedTransfer}.
    */
    function forcedTransfer(address _from, address _to, uint256 _amount) public override onlyAgent returns (bool) {
        uint256 freeBalance = balanceOf(_from).sub(frozenTokens[_from]);
        if (_amount > freeBalance) {
            uint256 tokensToUnfreeze = _amount.sub(freeBalance);
            frozenTokens[_from] = frozenTokens[_from].sub(tokensToUnfreeze);
            emit TokensUnfrozen(_from, tokensToUnfreeze);
        }
        if (tokenIdentityRegistry.isVerified(_to)) {
            tokenCompliance.transferred(_from, _to, _amount);
            _transfer(_from, _to, _amount);
            return true;
        }
        revert("Transfer not possible");
    }

   /**
    *  @dev See {IToken-batchForcedTransfer}.
    */
    function batchForcedTransfer(address[] calldata _fromList, address[] calldata _toList, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _fromList.length; i++) {
            forcedTransfer(_fromList[i], _toList[i], _amounts[i]);
        }
    }

   /**
    *  @dev See {IToken-mint}.
    */
    function mint(address _to, uint256 _amount) public override onlyAgent {
        require(tokenIdentityRegistry.isVerified(_to), "Identity is not verified.");
        require(tokenCompliance.canTransfer(msg.sender, _to, _amount), "Compliance not followed");
        _mint(_to, _amount);
        tokenCompliance.created(_to, _amount);
    }

   /**
    *  @dev See {IToken-batchMint}.
    */
    function batchMint(address[] calldata _toList, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _toList.length; i++) {
            mint(_toList[i], _amounts[i]);
        }
    }

   /**
    *  @dev See {IToken-burn}.
    */
    function burn(address _userAddress, uint256 _amount) public override onlyAgent {
        uint256 freeBalance = balanceOf(_userAddress) - frozenTokens[_userAddress];
        if (_amount > freeBalance) {
            uint256 tokensToUnfreeze = _amount.sub(freeBalance);
            frozenTokens[_userAddress] = frozenTokens[_userAddress].sub(tokensToUnfreeze);
            emit TokensUnfrozen(_userAddress, tokensToUnfreeze);
        }
        _burn(_userAddress, _amount);
        tokenCompliance.destroyed(_userAddress, _amount);
    }

   /**
    *  @dev See {IToken-batchBurn}.
    */
    function batchBurn(address[] calldata _userAddresses, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _userAddresses.length; i++) {
            burn(_userAddresses[i], _amounts[i]);
        }
    }

   /**
    *  @dev See {IToken-setAddressFrozen}.
    */
    function setAddressFrozen(address _userAddress, bool _freeze) public override onlyAgent {
        frozen[_userAddress] = _freeze;

        emit AddressFrozen(_userAddress, _freeze, msg.sender);
    }

   /**
    *  @dev See {IToken-batchSetAddressFrozen}.
    */
    function batchSetAddressFrozen(address[] calldata _userAddresses, bool[] calldata _freeze) external override {
        for (uint256 i = 0; i < _userAddresses.length; i++) {
            setAddressFrozen(_userAddresses[i], _freeze[i]);
        }
    }

   /**
    *  @dev See {IToken-freezePartialTokens}.
    */
    function freezePartialTokens(address _userAddress, uint256 _amount) public override onlyAgent {
        uint256 balance = balanceOf(_userAddress);
        require(balance >= frozenTokens[_userAddress] + _amount, "Amount exceeds available balance");
        frozenTokens[_userAddress] = frozenTokens[_userAddress].add(_amount);
        emit TokensFrozen(_userAddress, _amount);
    }

   /**
    *  @dev See {IToken-batchFreezePartialTokens}.
    */
    function batchFreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _userAddresses.length; i++) {
            freezePartialTokens(_userAddresses[i], _amounts[i]);
        }
    }

   /**
    *  @dev See {IToken-unfreezePartialTokens}.
    */
    function unfreezePartialTokens(address _userAddress, uint256 _amount) public override onlyAgent {
        require(frozenTokens[_userAddress] >= _amount, "Amount should be less than or equal to frozen tokens");
        frozenTokens[_userAddress] = frozenTokens[_userAddress].sub(_amount);
        emit TokensUnfrozen(_userAddress, _amount);
    }

   /**
    *  @dev See {IToken-batchUnfreezePartialTokens}.
    */
    function batchUnfreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external override {
        for (uint256 i = 0; i < _userAddresses.length; i++) {
            unfreezePartialTokens(_userAddresses[i], _amounts[i]);
        }
    }

   /**
    *  @dev See {IToken-setIdentityRegistry}.
    */
    function setIdentityRegistry(address _identityRegistry) external override onlyOwner {
        tokenIdentityRegistry = IIdentityRegistry(_identityRegistry);
        emit IdentityRegistryAdded(_identityRegistry);
    }

   /**
    *  @dev See {IToken-setCompliance}.
    */
    function setCompliance(address _compliance) external override onlyOwner {
        tokenCompliance = ICompliance(_compliance);
        emit ComplianceAdded(_compliance);
    }

   /**
    *  @dev See {IToken-recoveryAddress}.
    */
    function recoveryAddress(address _lostWallet, address _newWallet, address _investorOnchainID) external override onlyAgent returns (bool){
        require(balanceOf(_lostWallet) != 0, "no tokens to recover");
        IIdentity _onchainID = IIdentity(_investorOnchainID);
        bytes32 _key = keccak256(abi.encode(_newWallet));
        if (_onchainID.keyHasPurpose(_key, 1)) {
            uint investorTokens = balanceOf(_lostWallet);
            uint _frozenTokens = frozenTokens[_lostWallet];
            tokenIdentityRegistry.registerIdentity(_newWallet, _onchainID, tokenIdentityRegistry.investorCountry(_lostWallet));
            tokenIdentityRegistry.deleteIdentity(_lostWallet);
            forcedTransfer(_lostWallet, _newWallet, investorTokens);
            if (_frozenTokens > 0) {
                freezePartialTokens(_newWallet, _frozenTokens);
            }
            if (frozen[_lostWallet] == true) {
                setAddressFrozen(_newWallet, true);
            }
            emit RecoverySuccess(_lostWallet, _newWallet, _investorOnchainID);
            return true;
        }
        revert("Recovery not possible");
    }

   /**
    *  @dev See {IToken-transferOwnershipOnTokenContract}.
    */
    function transferOwnershipOnTokenContract(address _newOwner) external onlyOwner override {
        transferOwnership(_newOwner);
    }

   /**
    *  @dev See {IToken-addAgentOnTokenContract}.
    */
    function addAgentOnTokenContract(address _agent) external override {
        addAgent(_agent);
    }

   /**
    *  @dev See {IToken-removeAgentOnTokenContract}.
    */
    function removeAgentOnTokenContract(address _agent) external override {
        removeAgent(_agent);
    }
}
